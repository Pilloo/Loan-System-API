using Core.Domain;
using Core.DTOs;
using Core.Interfaces;
using Core.Notifications.Notifications;
using Core.UseCases.Commands;
using MediatR;
using Microsoft.AspNetCore.Identity;
using Shared;
using Shared.ErrorHandling;
using InternalServerError = Shared.ErrorHandling.InternalServerError;

namespace Core.UseCases.Handlers;

public class LoginCommandHandler : IRequestHandler<LoginCommand, Result<LoginResponse>>
{
    private readonly UserManager<User> _userManager;
    private readonly IIdentityService _identityService;
    private readonly SignInManager<User> _signInManager;
    private readonly IMediator _mediator;

    public LoginCommandHandler(UserManager<User> userManager, IIdentityService identityService,
        SignInManager<User> signInManager, IMediator mediator)
    {
        _userManager = userManager;
        _identityService = identityService;
        _signInManager = signInManager;
        _mediator = mediator;
    }

    /// <summary>
    /// Processes the <see cref="LoginCommand"/>.
    /// </summary>
    /// <param name="request">The <see cref="LoginCommand"/> with the data necessary to work.</param>
    /// <param name="cancellationToken">Cancellation token used to stop the operation gracefully.</param>
    /// <returns>A <see cref="Result{T}"/> with the <see cref="LoginResponse"/> or the <see cref="InternalError"/> generated by the handler.</returns>
    public async Task<Result<LoginResponse>> Handle(LoginCommand request,
        CancellationToken cancellationToken)
    {
        if (FieldsValidator.ValidateFields(request))
            return Result<LoginResponse>.Failure(new EmptyFields());

        var user = await _userManager.FindByNameAsync(request.Username);

        if (user is null)
            return Result<LoginResponse>.Failure(new InvalidCredentials());

        var accessGranted = await _signInManager.CheckPasswordSignInAsync(user, request.Password, false);

        if (!accessGranted.Succeeded)
            return Result<LoginResponse>.Failure(new InvalidCredentials());

        var emailVerified = await _userManager.IsEmailConfirmedAsync(user);

        if (!emailVerified)
        {
            await _mediator.Publish(new SendEmailVerificationEvent(user.Email!), cancellationToken);
            return Result<LoginResponse>.Failure(new EmailNotVerified());
        }

        var token = await _identityService.GenerateAccessToken(user);

        LoginResponse response;
        
        if (!request.RememberMe)
        {
            response = new LoginResponse
            {
                Token = token,
            };
            
            return Result<LoginResponse>.Success(response);
        }

        var refreshToken = await _identityService.GenerateRefreshToken();
        user.RefreshToken = refreshToken;
        var updateResult = await _userManager.UpdateAsync(user);
        
        if (!updateResult.Succeeded)
        {
            return Result<LoginResponse>.Failure(new InternalServerError());
        }
        
        response = new LoginResponse
        {
            Token = token,
            RefreshToken = refreshToken,
        };
        
        return Result<LoginResponse>.Success(response);
    }
}