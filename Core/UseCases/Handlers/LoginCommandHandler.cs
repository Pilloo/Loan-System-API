using Core.Domain;
using Core.UseCases.Commands;
using Core.DTOs;
using Core.Interfaces;
using Core.Shared;
using MediatR;
using Microsoft.AspNetCore.Identity;
using InternalServerError = Core.Shared.InternalServerError;

namespace Core.UseCases.Handlers;

public class LoginCommandHandler : IRequestHandler<LoginCommand, Result<LoginResponse>>
{
    private readonly UserManager<User> _userManager;
    private readonly IIdentityService _identityService;
    private readonly SignInManager<User> _signInManager;
    
    public LoginCommandHandler(UserManager<User> userManager, IIdentityService identityService, SignInManager<User> signInManager)
    {
        _userManager = userManager;
        _identityService = identityService;
        _signInManager = signInManager;
    }

    /// <summary>
    /// Processes the <see cref="LoginCommand"/>.
    /// </summary>
    /// <param name="request">The <see cref="LoginCommand"/> with the data necessary to work.</param>
    /// <returns>A <see cref="Result{T}"/> with the <see cref="LoginResponse"/> or the <see cref="InternalError"/> generated by the handler.</returns>
    public async Task<Result<LoginResponse>> Handle(LoginCommand request,
        CancellationToken cancellationToken)
    {
        if (EmptyMembersChecker.HasEmptyMembers(request))
            return Result<LoginResponse>.Failure(new EmailOrPasswordFieldsEmpty());

        var user = await _userManager.FindByNameAsync(request.Username);

        if (user is null)
            return Result<LoginResponse>.Failure(new UsernameOrPasswordIncorrect());

        var accessGranted = await _signInManager.CheckPasswordSignInAsync(user, request.Password, false);

        if (!accessGranted.Succeeded)
            return Result<LoginResponse>.Failure(new UsernameOrPasswordIncorrect());

        var emailVerified = await _userManager.IsEmailConfirmedAsync(user);

        /*
         * Instead of return EmailNotVerified, it should create a request to and endpoint (or call directly to the code)
         * that generates a new confirmation token. This API call could be shared between commands and after the
         * confirmation succeed, the user should be redirected to the login page again.
         */
        if (!emailVerified) return Result<LoginResponse>.Failure(new EmailNotVerified());

        var token = await _identityService.GenerateAccessToken(user);
        var refreshToken = await _identityService.GenerateRefreshToken();

        user.RefreshToken = refreshToken;
        var updateResult = await _userManager.UpdateAsync(user);

        if (!updateResult.Succeeded)
        {
            return Result<LoginResponse>.Failure(new InternalServerError());
        }

        LoginResponse response = new LoginResponse
        {
            Token = token,
            RefreshToken = refreshToken,
            RedirectTo = "/"
        };

        return Result<LoginResponse>.Success(response);
    }
}