using Core.Domain;
using Core.DTOs;
using Core.Interfaces;
using Core.Notifications.Notifications;
using Core.UseCases.Commands;
using MediatR;
using Microsoft.AspNetCore.Identity;
using ErrorHandling;
using ErrorHandling.Service;

namespace Core.UseCases.Handlers;

public class LoginCommandHandler(
    UserManager<User> userManager,
    IIdentityService identityService,
    SignInManager<User> signInManager,
    IMediator mediator,
    ProblemDetailsService problemDetailsService)
    : IRequestHandler<LoginCommand, Result<LoginResponse>>
{
    /// <summary>
    /// Processes the <see cref="LoginCommand"/>.
    /// </summary>
    /// <param name="request">The <see cref="LoginCommand"/> with the data necessary to work.</param>
    /// <param name="cancellationToken">Cancellation token used to stop the operation gracefully.</param>
    /// <returns>A <see cref="Result{T}"/> with the <see cref="LoginResponse"/> or the <see cref="InternalError"/>
    /// generated by the handler.</returns>
    public async Task<Result<LoginResponse>> Handle(LoginCommand request,
        CancellationToken cancellationToken)
    {
        var user = await userManager.FindByNameAsync(request.Username);

        if (user is null)
            return Result<LoginResponse>.Failure(
                problemDetailsService.CreateProblemDetails(new InvalidCredentialsOrEmailNotVerified()));

        var accessGranted = await signInManager.PasswordSignInAsync(user, request.Password, false, false);

        if (!accessGranted.Succeeded)
            return Result<LoginResponse>.Failure(
                problemDetailsService.CreateProblemDetails(new InvalidCredentialsOrEmailNotVerified()));

        var emailVerified = await userManager.IsEmailConfirmedAsync(user);

        if (!emailVerified)
        {
            await mediator.Publish(new SendEmailVerificationEvent(user.Email!), cancellationToken);
            return Result<LoginResponse>.Failure(
                problemDetailsService.CreateProblemDetails(new InvalidCredentialsOrEmailNotVerified()));
        }

        var token = await identityService.GenerateAccessToken(user);

        LoginResponse response;

        if (!request.RememberMe)
        {
            response = new LoginResponse
            {
                Token = token,
            };

            return Result<LoginResponse>.Success(response);
        }

        var refreshToken = await identityService.GenerateRefreshToken();
        user.RefreshToken = refreshToken;
        var updateResult = await userManager.UpdateAsync(user);

        if (!updateResult.Succeeded)
        {
            return Result<LoginResponse>.Failure(problemDetailsService.CreateProblemDetails(new InternalServerError()));
        }

        response = new LoginResponse
        {
            Token = token,
            RefreshToken = refreshToken,
        };

        return Result<LoginResponse>.Success(response);
    }
}